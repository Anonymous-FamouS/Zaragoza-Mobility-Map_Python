# -*- coding: utf-8 -*-
"""Untitled32.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N9PcuAlOb-0jgGRiQjwRIx-wLrFMA15L
"""

!pip install osmnx


# 1) System dependencies (Colab) and Python libraries
!apt-get update -qq
!apt-get install -y -qq libspatialindex-dev   # helps geopandas/rtree
!pip install --quiet pandas geopandas folium osmnx requests shapely pyproj

# GTFS/RT helpers for transit analysis
!pip install gtfs-kit gtfs-realtime-bindings partridge

# Additional libraries for urban mobility analysis
!pip install --quiet matplotlib seaborn plotly contextily


# 1) System dependencies (Colab) and Python libraries
!apt-get update -qq
!apt-get install -y -qq libspatialindex-dev   # helps geopandas/rtree
!pip install --quiet pandas geopandas folium osmnx requests shapely pyproj

# GTFS/RT helpers for transit analysis
!pip install gtfs-kit gtfs-realtime-bindings partridge

# Additional libraries for urban mobility analysis
!pip install --quiet matplotlib seaborn plotly contextily

# 2) Helpers: download GTFS zip OR upload manually
import os
import io
import zipfile
import requests
from google.colab import files
import pandas as pd
import geopandas as gpd
import folium
import gtfs_kit as gk

GTFS_DIR = "gtfs_data"
os.makedirs(GTFS_DIR, exist_ok=True)

# Option A: set a direct GTFS URL here (Transitland/NAP may require API key)
GTFS_URL = ""  # e.g. "https://.../zaragoza_gtfs.zip" or leave blank to upload

def extract_gtfs_from_bytes(b, outdir=GTFS_DIR):
    z = zipfile.ZipFile(io.BytesIO(b))
    z.extractall(outdir)
    print("Extracted files:", z.namelist())

if GTFS_URL:
    print("Downloading GTFS from URL...")
    r = requests.get(GTFS_URL)
    r.raise_for_status()
    extract_gtfs_from_bytes(r.content)
else:
    print("Please upload your GTFS .zip file(s) - you can upload multiple files for bus and tram data")
    uploaded = files.upload()
    for fn, b in uploaded.items():
        if fn.lower().endswith(".zip"):
            # Create separate directories for different transit modes
            if "bus" in fn.lower() or "avanza" in fn.lower():
                bus_dir = os.path.join(GTFS_DIR, "bus")
                os.makedirs(bus_dir, exist_ok=True)
                extract_gtfs_from_bytes(b, bus_dir)
            elif "tranvia" in fn.lower() or "tram" in fn.lower():
                tram_dir = os.path.join(GTFS_DIR, "tram")
                os.makedirs(tram_dir, exist_ok=True)
                extract_gtfs_from_bytes(b, tram_dir)
            else:
                extract_gtfs_from_bytes(b, GTFS_DIR)
        else:
            open(os.path.join(GTFS_DIR, fn), "wb").write(b)
            print("Saved", fn)



# Load the bus GTFS data using gtfs-kit
print("üöå Loading Zaragoza Bus GTFS Data...")
print("=" * 50)

# Load the bus feed
bus_feed = gk.read_feed(os.path.join(GTFS_DIR, "bus"), dist_units='km')

print("‚úÖ Bus GTFS data loaded successfully!")
print(f"üìä Data Summary:")
print(f"   ‚Ä¢ Routes: {len(bus_feed.routes)}")
print(f"   ‚Ä¢ Stops: {len(bus_feed.stops)}")
print(f"   ‚Ä¢ Trips: {len(bus_feed.trips)}")
print(f"   ‚Ä¢ Stop Times: {len(bus_feed.stop_times)}")

# Display basic route information
print(f"\nüöç Bus Routes Overview:")
route_cols = ['route_id', 'route_short_name', 'route_long_name', 'route_type']
available_cols = [col for col in route_cols if col in bus_feed.routes.columns]
print(bus_feed.routes[available_cols].head(10))

# Geographic coverage
print(f"\nüìç Geographic Coverage:")
print(f"   Latitude range: {bus_feed.stops['stop_lat'].min():.4f} to {bus_feed.stops['stop_lat'].max():.4f}")
print(f"   Longitude range: {bus_feed.stops['stop_lon'].min():.4f} to {bus_feed.stops['stop_lon'].max():.4f}")

# Check agency information
if hasattr(bus_feed, 'agency') and not bus_feed.agency.empty:
    print(f"\nüè¢ Transit Agency:")
    print(bus_feed.agency[['agency_name', 'agency_url']].head())


# Number 1: Import Libraries
import pandas as pd
import os
import geopandas as gpd
import folium
from folium.plugins import GroupedLayerControl
from branca.element import Element
import branca # Add this line to import the branca library

print("‚úÖ Libraries imported.")

# Number 2: Load Bike Lane Data

# --- Code to load and combine bike lane shapefiles ---
bike_lane_folder = '/content/Bike Lane'

# Check if the folder exists
if not os.path.exists(bike_lane_folder):
    print(f"Error: Bike lane folder not found at {bike_lane_folder}. Skipping bike lane data loading.")
    combined_bike_lanes = None
else:
    print(f"Listing files in {bike_lane_folder}: {os.listdir(bike_lane_folder)}")

    # Define the shapefile names
    shapefile_names = [
        'Carriles Calmados.shp',
        'Carriles Bidireccionales.shp',
        'Carriles Unidireccionales.shp',
        'Sendas Ciclables.shp'
    ]

    # Initialize an empty list to hold GeoDataFrames
    gdfs = []

    # Load each shapefile and append to the list
    print("Loading bike lane shapefiles...")
    for shapefile in shapefile_names:
        shapefile_path = os.path.join(bike_lane_folder, shapefile)
        if os.path.exists(shapefile_path):
            try:
                gdf = gpd.read_file(shapefile_path)
                gdfs.append(gdf)
                print(f"Successfully loaded {shapefile} with CRS: {gdf.crs}") # Print CRS on load
            except Exception as e:
                print(f"Error loading {shapefile}: {e}")
        else:
            print(f"Warning: Shapefile not found at {shapefile_path}. Skipping.")


    # Concatenate all GeoDataFrames into one
    combined_bike_lanes = None # Initialize to None
    if gdfs: # Only concatenate if at least one GeoDataFrame was loaded
        combined_bike_lanes = gpd.GeoDataFrame(pd.concat(gdfs, ignore_index=True))
        print(f"Successfully combined {len(gdfs)} shapefiles into combined_bike_lanes GeoDataFrame.")
        print(f"Combined GeoDataFrame has {len(combined_bike_lanes)} features.")

        # --- Reproject to EPSG:4326 for Folium ---
        if combined_bike_lanes.crs is None:
            print("Combined GeoDataFrame has no CRS. Attempting to set a common local CRS (EPSG:25830) and reproject.")
            # Assuming a common projected CRS for Zaragoza area - EPSG:25830 (ETRS89 / UTM zone 30N)
            # You might need to change this if your data is in a different CRS
            try:
                 combined_bike_lanes = combined_bike_lanes.set_crs(epsg=25830, allow_override=True)
                 print(f"CRS set to {combined_bike_lanes.crs}")
                 combined_bike_lanes = combined_bike_lanes.to_crs(epsg=4326)
                 print(f"Reprojected combined GeoDataFrame to EPSG:4326. New CRS: {combined_bike_lanes.crs}")
            except Exception as e:
                 print(f"Error setting or reprojecting CRS: {e}")
                 print("Skipping CRS transformation. Map layer might not display correctly.")
                 combined_bike_lanes = None # Set to None if reprojection fails

        elif combined_bike_lanes.crs.to_epsg() != 4326:
            print(f"Combined GeoDataFrame is in CRS {combined_bike_lanes.crs}. Reprojecting to EPSG:4326.")
            try:
                combined_bike_lanes = combined_bike_lanes.to_crs(epsg=4326)
                print(f"Reprojected combined GeoDataFrame to EPSG:4326. New CRS: {combined_bike_lanes.crs}")
            except Exception as e:
                print(f"Error reprojecting CRS: {e}")
                print("Skipping CRS transformation. Map layer might not display correctly.")
                combined_bike_lanes = None # Set to None if reprojection fails

        else:
            print(f"Combined GeoDataFrame is already in EPSG:4326. CRS: {combined_bike_lanes.crs}")

        # Convert datetime columns to string for JSON serialization if combined_bike_lanes is valid
        if combined_bike_lanes is not None:
             for col in combined_bike_lanes.columns:
                if pd.api.types.is_datetime64_any_dtype(combined_bike_lanes[col]):
                    combined_bike_lanes[col] = combined_bike_lanes[col].astype(str)


    else:
        print("No shapefiles were successfully loaded. combined_bike_lanes is None.")

print("‚úÖ Bike lane data loading and processing complete.")

# Number 3: Load GTFS Data (or use dummy data)

# Assume bus_feed is already loaded, e.g., from gtfs_kit.read_gtfs()
# Placeholder for bus_feed if not defined (replace with your actual GTFS data loading)
try:
    bus_feed
    print("‚úÖ Existing bus_feed found.")
except NameError:
    print("WARNING: bus_feed not found. Using dummy data for demonstration.")
    # Create dummy bus_feed for demonstration if not provided
    data = {
        'stops': pd.DataFrame({
            'stop_id': ['stopA', 'stopB', 'stopC', 'stopD', 'stopE', 'stopF', 'stopG', 'stopH', 'stopI', 'stopJ'],
            'stop_name': ['Bus Stop A', 'Bus Stop B', 'Tram Stop C', 'Bus Stop D', 'Tram Stop E', 'Bus Stop F', 'Bus Stop G', 'Tram Stop H', 'Bus Stop I', 'Tram Stop J'],
            'stop_lat': [41.648, 41.650, 41.649, 41.647, 41.651, 41.652, 41.646, 41.653, 41.645, 41.654],
            'stop_lon': [-0.890, -0.888, -0.892, -0.887, -0.891, -0.886, -0.893, -0.885, -0.894, -0.884]
        }),
        'routes': pd.DataFrame({
            'route_id': ['R1', 'R2', 'T1', 'R3', 'R4', 'T2', 'R5', 'T3'],
            'route_short_name': ['1', '2', 'Tram 1', '3', '4', 'Tram 2', '5', 'Tram 3'],
            'route_type': [3, 3, 0, 3, 3, 0, 3, 0], # 3 for bus, 0 for tram
            'route_color': ['FF0000', '00FF00', '0000FF', 'FFFF00', 'FF00FF', '00FFFF', 'FFA500', '800080'] # Various colors
        }),
        'trips': pd.DataFrame({
            'trip_id': ['trip1A', 'trip1B', 'trip2A', 'tripT1A', 'trip2B', 'trip3A', 'trip4A', 'tripT2A', 'trip5A', 'tripT3A'],
            'route_id': ['R1', 'R1', 'R2', 'T1', 'R2', 'R3', 'R4', 'T2', 'R5', 'T3']
        }),
        'stop_times': pd.DataFrame({
            'trip_id': ['trip1A', 'trip1A', 'trip2A', 'tripT1A', 'tripT1A', 'trip2B', 'trip3A', 'trip3A', 'trip4A', 'tripT2A', 'trip5A', 'tripT3A'],
            'stop_id': ['stopA', 'stopB', 'stopA', 'stopC', 'stopE', 'stopC', 'stopF', 'stopG', 'stopI', 'stopH', 'stopJ', 'stopC'],
            'stop_sequence': [1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1]
        })
    }
    class MockGTFSFeed:
        def __init__(self, data):
            self.stops = data['stops']
            self.routes = data['routes']
            self.trips = data['trips']
            self.stop_times = data['stop_times']
    bus_feed = MockGTFSFeed(data)

print("‚úÖ GTFS data loaded or dummy data created.")

# Number 5.5: Generate Route Feature Groups for Main Map

print("Generating Feature Groups for individual routes and combined bus grid for main map...")

# Assuming 'bus_feed' is already loaded and available from previous cells

# Dictionary to hold FeatureGroups for individual routes (colorful lines)
individual_route_fgs = {}
# FeatureGroup for the combined bus grid (blue line)
combined_bus_grid_fg = None
# FeatureGroup for the individual tram line(s) (consistent color line)
individual_tram_line_fg = None

# Import LineString from shapely.geometry
from shapely.geometry import LineString

# Ensure stops DataFrame is indexed by stop_id for quick lookup
stops_indexed = bus_feed.stops.set_index('stop_id')

# --- Generate Feature Groups for Individual Routes (Colorful Lines) ---
# This logic is adapted from cell vjn6YWt4kbPt

# Get unique trips
unique_trips = bus_feed.trips['trip_id'].unique()

for trip_id in unique_trips:
    trip_stop_times = bus_feed.stop_times[bus_feed.stop_times['trip_id'] == trip_id].sort_values(by='stop_sequence')

    if len(trip_stop_times) > 1:
        route_info = bus_feed.trips[bus_feed.trips['trip_id'] == trip_id]
        if not route_info.empty:
            route_id = route_info.iloc[0]['route_id']
            route_details = bus_feed.routes[bus_feed.routes['route_id'] == route_id]

            route_color = '#0052CC' # Default color
            route_name = str(route_id)
            transport_mode = 'bus' # Default mode

            if not route_details.empty:
                route_data = route_details.iloc[0]
                route_color = route_data.get('route_color', '#0052CC')
                route_name = route_data.get('route_short_name', str(route_id))
                route_type = route_data.get('route_type', 3)
                transport_mode = 'tram' if route_type == 0 else 'bus'

                # Clean color
                if route_color and isinstance(route_color, str) and route_color != '':
                    route_color = route_color.replace('#', '')
                    if len(route_color) == 6:
                        route_color = f"#{route_color}"
                    else:
                        route_color = "#0052CC"


            route_points = []
            valid_trip = True
            for stop_id in trip_stop_times['stop_id']:
                if stop_id in stops_indexed.index and pd.notna(stops_indexed.loc[stop_id]['stop_lat']) and pd.notna(stops_indexed.loc[stop_id]['stop_lon']):
                     route_points.append([stops_indexed.loc[stop_id]['stop_lat'], stops_indexed.loc[stop_id]['stop_lon']])
                else:
                    # print(f"Warning: Stop ID '{stop_id}' not found in stops data or has missing coordinates for trip '{trip_id}'. Skipping trip.")
                    valid_trip = False
                    break

            if valid_trip and len(route_points) > 1:
                # Create a FeatureGroup for this individual trip's route line
                mode_icon = 'üöå' if transport_mode == 'bus' else 'üöã'
                # Use route_short_name for the display name
                fg_name = f"{mode_icon} Route {route_name} ({route_id})" # Include route_id for uniqueness

                if fg_name not in individual_route_fgs:
                     individual_route_fgs[fg_name] = folium.FeatureGroup(name=fg_name, show=False, overlay=True)

                # Add the route as a PolyLine to its FeatureGroup
                folium.PolyLine(
                    locations=route_points,
                    color=route_color,
                    weight=3 if transport_mode == 'bus' else 4, # Thicker line for tram
                    opacity=0.7,
                    tooltip=f"{transport_mode.capitalize()} Route {route_name} ({route_id}) - Trip {trip_id}"
                ).add_to(individual_route_fgs[fg_name])


print("Individual route Feature Groups created.")

# --- Generate Feature Group for Combined Bus Grid (Blue Line) ---
# This logic is adapted from cell 4ImJi-Kt-a0P

print("Generating Feature Group for combined bus grid...")

# Filter for bus routes (assuming route_type 3 is bus)
bus_route_ids = bus_feed.routes[bus_feed.routes['route_type'] == 3]['route_id'].tolist()
bus_trips = bus_feed.trips[bus_feed.trips['route_id'].isin(bus_route_ids)]

all_bus_linestrings = []

for trip_id in bus_trips['trip_id'].unique():
    trip_stop_times = bus_feed.stop_times[bus_feed.stop_times['trip_id'] == trip_id].sort_values(by='stop_sequence')

    route_points = []
    valid_trip = True
    for stop_id in trip_stop_times['stop_id']:
        if stop_id in stops_indexed.index and pd.notna(stops_indexed.loc[stop_id]['stop_lat']) and pd.notna(stops_indexed.loc[stop_id]['stop_lon']):
             route_points.append((stops_indexed.loc[stop_id]['stop_lon'], stops_indexed.loc[stop_id]['stop_lat'])) # Note: Shapely expects (lon, lat)
        else:
            valid_trip = False
            break

    if valid_trip and len(route_points) > 1:
        try:
            line = LineString(route_points)
            all_bus_linestrings.append(line)
        except Exception as e:
            print(f"Error creating LineString for trip {trip_id}: {e}")

if all_bus_linestrings:
    bus_routes_gdf = gpd.GeoDataFrame(geometry=all_bus_linestrings, crs="EPSG:4326")

    # Create a FeatureGroup for the combined bus grid
    combined_bus_grid_fg = folium.FeatureGroup(name='Bus', show=True, overlay=True) # Show by default as per user's requirement for mode control

    folium.GeoJson(
        bus_routes_gdf,
        name='Combined Bus Routes GeoJson', # Internal name
        style_function=lambda x: {
            'color': 'blue',
            'weight': 2,
            'opacity': 0.7,
        }
    ).add_to(combined_bus_grid_fg)

    print("Combined bus grid Feature Group created.")
else:
    print("No bus route LineStrings were created for the combined grid.")
    combined_bus_grid_fg = None # Ensure it's None if no data

# --- Generate Feature Group for Individual Tram Line(s) (Consistent Color Line) ---
# This is a new requirement - similar to combined bus grid but filtered for trams

print("Generating Feature Group for individual tram line(s)...")

# Filter for tram routes (assuming route_type 0 is tram)
tram_route_ids = bus_feed.routes[bus_feed.routes['route_type'] == 0]['route_id'].tolist()
tram_trips = bus_feed.trips[bus_feed.trips['route_id'].isin(tram_route_ids)]

all_tram_linestrings = []

for trip_id in tram_trips['trip_id'].unique():
    trip_stop_times = bus_feed.stop_times[bus_feed.stop_times['trip_id'] == trip_id].sort_values(by='stop_sequence')

    route_points = []
    valid_trip = True
    for stop_id in trip_stop_times['stop_id']:
        if stop_id in stops_indexed.index and pd.notna(stops_indexed.loc[stop_id]['stop_lat']) and pd.notna(stops_indexed.loc[stop_id]['stop_lon']):
             # FIX: Corrected 'stop_lat' to 'stops_indexed.loc[stop_id]['stop_lat']'
             route_points.append((stops_indexed.loc[stop_id]['stop_lon'], stops_indexed.loc[stop_id]['stop_lat'])) # Note: Shapely expects (lon, lat)
        else:
            valid_trip = False
            break

    if valid_trip and len(route_points) > 1:
        try:
            line = LineString(route_points)
            all_tram_linestrings.append(line)
        except Exception as e:
            print(f"Error creating LineString for tram trip {trip_id}: {e}")

if all_tram_linestrings:
    tram_routes_gdf = gpd.GeoDataFrame(geometry=all_tram_linestrings, crs="EPSG:4326")

    # Get the consistent color for the tram route from GTFS data
    tram_color = '#00CC00' # Default green if not found
    if tram_route_ids:
         tram_route_details = bus_feed.routes[bus_feed.routes['route_id'] == tram_route_ids[0]]
         if not tram_route_details.empty:
             tram_color_gtfs = tram_route_details.iloc[0].get('route_color', '00CC00')
             if tram_color_gtfs and isinstance(tram_color_gtfs, str) and tram_color_gtfs != '':
                    tram_color_gtfs = tram_color_gtfs.replace('#', '')
                    if len(tram_color_gtfs) == 6:
                        tram_color = f"#{tram_color_gtfs}"
                    else:
                        tram_color = "#00CC00"
             else:
                  tram_color = "#00CC00"


    # Create a FeatureGroup for the individual tram line(s)
    individual_tram_line_fg = folium.FeatureGroup(name='Tram', show=True, overlay=True) # Show by default

    folium.GeoJson(
        tram_routes_gdf,
        name='Individual Tram Line(s) GeoJson', # Internal name
        style_function=lambda x: {
            'color': tram_color,
            'weight': 4, # Thicker line for tram
            'opacity': 0.8,
        }
    ).add_to(individual_tram_line_fg)

    print("Individual tram line(s) Feature Group created.")
else:
    print("No tram route LineStrings were created.")
    individual_tram_line_fg = None # Ensure it's None if no data

print("‚úÖ Route Feature Groups for main map generated.")

# Number 4: Walking edges and gap
import osmnx as ox
import folium
import geopandas as gpd
# 1. Extract the full street network
full_network = ox.graph_from_place("Zaragoza, Spain", network_type="all")

# 2. Convert to GeoDataFrame of edges
full_edges_gdf = ox.graph_to_gdfs(full_network, nodes=False, edges=True)

# 3. Calculate the total number of edges in the full network
num_full_edges = len(full_edges_gdf)
print(f"Total edges in the full street network: {num_full_edges}")

# Extract walking network again as walking_edges_gdf was not defined in the previous cell
walking_network = ox.graph_from_place("Zaragoza, Spain", network_type="walk")
walking_edges_gdf = ox.graph_to_gdfs(walking_network, nodes=False, edges=True)


# 4. Calculate the total number of edges in the walking network
num_walking_edges = len(walking_edges_gdf)
print(f"Total edges in the walking network: {num_walking_edges}")

# 5. Calculate the percentage of walking network coverage
coverage_percentage = (num_walking_edges / num_full_edges) * 100

# 6. Print the calculated coverage_percentage
print(f"Walking network coverage: {coverage_percentage:.2f}% of the full street network.")

# Number 5: Walking spatial anti-join

# Perform a spatial anti-join
gaps_gdf = full_edges_gdf.overlay(walking_edges_gdf, how='difference', keep_geom_type=False)

# Inspect the resulting gaps_gdf
display(gaps_gdf.head())

## Number 6: Cycling
# 1. Extract the cycling network
cycling_network = ox.graph_from_place("Zaragoza, Spain", network_type="bike")

# 2. Convert to GeoDataFrame of edges
cycling_edges_gdf = ox.graph_to_gdfs(cycling_network, nodes=False, edges=True)

# 3. Calculate the total number of edges in the cycling network
num_cycling_edges = len(cycling_edges_gdf)
print(f"Total edges in the cycling network: {num_cycling_edges}")

# 4. Calculate the percentage of cycling network coverage
# num_full_edges is already available from a previous cell
cycling_coverage_percentage = (num_cycling_edges / num_full_edges) * 100

# 5. Print the calculated cycling_coverage_percentage
print(f"Cycling network coverage: {cycling_coverage_percentage:.2f}% of the full street network.")

# 6. Perform a spatial anti-join to find cycling gaps
# Ensure full_edges_gdf is in the same CRS as cycling_edges_gdf before overlay
if full_edges_gdf.crs != cycling_edges_gdf.crs:
    print(f"Reprojecting full_edges_gdf to {cycling_edges_gdf.crs} for overlay.")
    full_edges_gdf = full_edges_gdf.to_crs(cycling_edges_gdf.crs)

cycling_gaps_gdf = full_edges_gdf.overlay(cycling_edges_gdf, how='difference', keep_geom_type=False)

# 7. Display the head of the resulting cycling_gaps_gdf
display(cycling_gaps_gdf.head())

# 8. Print the number of identified gaps
print(f"Number of identified cycling gaps (edges): {len(cycling_gaps_gdf)}")

print(f"Summary of Cycling Infrastructure Analysis in Zaragoza:")
print(f"- The cycling network covers approximately {cycling_coverage_percentage:.2f}% of the full street network.")
print(f"- Identified {len(cycling_gaps_gdf)} potential gaps in the cycling infrastructure.")

# Number 6: Initialize Map and Base Layers

# Create the Folium map
zaragoza_center = [41.6488, -0.8891]
zw = folium.Map(
    location=zaragoza_center,
    zoom_start=12,
    tiles=None,  # Start with no default tiles to manage them explicitly
    control_scale=True,
    zoom_control=True,  # Ensure zoom control is enabled (it is by default)
    control_position='bottomright' # Change the position here (e.g., 'bottomright', 'topleft', 'topright')
)

# --- Add different tile layers as Base layers (radio button selection) ---
tile_layers = [
    ('OpenStreetMap', 'OpenStreetMap', 'üó∫Ô∏è Standard Map', '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'),
    ('CartoDB Positron', 'CartoDB Positron', 'üåü Light Theme', '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'),
    ('CartoDB Dark_Matter', 'CartoDB Dark_Matter', 'üåô Dark Theme', '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'),
    #('Stamen Toner', 'Stamen Toner', 'üì∞ High Contrast', 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'),
    #('Stamen Terrain', 'Stamen Terrain', 'üèîÔ∏è Terrain View', 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors')
]

# Add the first tile layer as default and visible
default_added = False
for display_name, tile_name, description, attribution in tile_layers:
    folium.TileLayer(
        tiles=tile_name,
        name=description,
        attr=attribution,
        overlay=False,  # Base layer (radio button)
        control=True,
        show=not default_added  # Only show the first one by default
    ).add_to(zw)
    if not default_added:
        default_added = True

print("‚úÖ Map initialized and base layers added.")

# Number 7: Create Feature Groups for Modes and Stops

# --- Create Feature Groups for different layers (Modes and Stops) ---

# 1. Mode and Stop Layers
mode_layers = {} # This dictionary will hold FeatureGroups for the modes/stops grouped layer control

# Add bike lanes to a feature group ONLY if combined_bike_lanes is available and valid
if 'combined_bike_lanes' in globals() and combined_bike_lanes is not None and not combined_bike_lanes.empty and combined_bike_lanes.crs is not None:
    print("Creating bike lanes Feature Group...")
    bike_lane_fg = folium.FeatureGroup(name='üö¥ Bike Lanes', overlay=True)
    folium.GeoJson(
        combined_bike_lanes,
        name='Bike Lanes GeoJson', # Internal name for GeoJson object
        style_function=lambda x: {
            'color': '#F26A0A', # Using the specific color code
            'weight': 2,
            'opacity': 0.7,
        },
        tooltip=folium.features.GeoJsonTooltip(fields=['calle', 'tipo_carri', 'longitud', 'ano_contru', 'estado'],
                                               aliases=['Street:', 'Type:', 'Length (m):', 'Constr. Year:', 'Status:'],
                                               localize=True)
    ).add_to(bike_lane_fg)
    mode_layers['üö¥ Bike Lanes'] = bike_lane_fg
    print("Bike lanes Feature Group created.")
else:
    print("Skipping creation of bike lanes Feature Group.")

# Add walking infrastructure gaps layer if available and valid
if 'gaps_gdf' in globals() and gaps_gdf is not None and not gaps_gdf.empty and gaps_gdf.crs is not None:
    print("Creating walking infrastructure gaps Feature Group...")
    walking_gaps_fg = folium.FeatureGroup(name='üö∂ Walking Gaps', overlay=True, show=False) # Start hidden
    folium.GeoJson(
        gaps_gdf,
        name='Walking Gaps GeoJson', # Internal name
        style_function=lambda x: {
            'color': 'red',
            'weight': 3,
            'opacity': 0.8,
        },
        tooltip=folium.features.GeoJsonTooltip(fields=['highway', 'name', 'length'],
                                               aliases=['Highway Type:', 'Street Name:', 'Length (m):'],
                                               localize=True)
    ).add_to(walking_gaps_fg)
    mode_layers['üö∂ Walking Gaps'] = walking_gaps_fg
    print("Walking gaps Feature Group created.")
else:
    print("Skipping creation of walking infrastructure gaps Feature Group.")

# Add cycling infrastructure gaps layer if available and valid
if 'cycling_gaps_gdf' in globals() and cycling_gaps_gdf is not None and not cycling_gaps_gdf.empty and cycling_gaps_gdf.crs is not None:
    print("Creating cycling infrastructure gaps Feature Group...")
    cycling_gaps_fg = folium.FeatureGroup(name='üö≤ Cycling Gaps', overlay=True, show=False) # Start hidden
    folium.GeoJson(
        cycling_gaps_gdf,
        name='Cycling Gaps GeoJson', # Internal name
        style_function=lambda x: {
            'color': 'purple',  # Use a different color for cycling gaps
            'weight': 3,
            'opacity': 0.8,
        },
        tooltip=folium.features.GeoJsonTooltip(fields=['highway', 'name', 'length'],
                                               aliases=['Highway Type:', 'Street Name:', 'Length (m):'],
                                               localize=True)
    ).add_to(cycling_gaps_fg)
    mode_layers['üö≤ Cycling Gaps'] = cycling_gaps_fg
    print("Cycling gaps Feature Group created.")
else:
    print("Skipping creation of cycling infrastructure gaps Feature Group.")


# Feature groups for Bus and Tram Stops
print("Creating Bus and Tram Stops Feature Groups...")
bus_stops_fg = folium.FeatureGroup(name='üöå Bus Stops', overlay=True)
tram_stops_fg = folium.FeatureGroup(name='üöã Tram Stops', overlay=True)

mode_layers['üöå Bus Stops'] = bus_stops_fg
mode_layers['üöã Tram Stops'] = tram_stops_fg
print("Bus and Tram Stops Feature Groups created.")


# The creation of Feature Groups for individual routes, combined bus grid,
# and individual tram line(s) is now handled in cell 5.5 (201ee10f).
# We no longer generate route_feature_groups or unique_routes here.


print("‚úÖ Feature groups for Modes and Stops created.")

# Number 8: Process and Add Stops

print(f"Processing {len(bus_feed.stops)} stops for map visualization...")
bus_stop_count = 0
tram_stop_count = 0
unknown_stop_count = 0

# Function to determine transport mode and color from route data
def get_route_info(stop_id, feed):
    """Get route information for a specific stop from the GTFS feed."""
    # Find trips that serve this stop
    trips_serving_stop_df = feed.stop_times[feed.stop_times['stop_id'] == stop_id]

    if trips_serving_stop_df.empty:
        # Ensure consistent return value count even if no trips are found
        return 'unknown', '#A9A9A9', 'Unknown Route', 'UNK'

    # Get unique trip_ids that serve this stop
    unique_trip_ids = trips_serving_stop_df['trip_id'].unique()

    # Collect all route info for the stop
    all_route_details = []

    for trip_id in unique_trip_ids:
        trip_info = feed.trips[feed.trips['trip_id'] == trip_id]
        if not trip_info.empty:
            route_id = trip_info.iloc[0]['route_id']
            route_info = feed.routes[feed.routes['route_id'] == route_id]

            if not route_info.empty:
                route_data = route_info.iloc[0]
                route_type = route_data.get('route_type', 3)  # Default to bus (3)
                route_color = route_data.get('route_color', '0052CC') # Default blue
                route_name = route_data.get('route_short_name', str(route_id))

                # Clean color (remove # if present, ensure 6 characters)
                if route_color and isinstance(route_color, str) and route_color != '':
                    route_color = route_color.replace('#', '')
                    if len(route_color) == 6:
                        route_color = f"#{route_color}"
                    else:
                        route_color = "#0052CC"  # Fallback to default blue if invalid length
                else:
                    route_color = "#0052CC" # Fallback if color is NaN or empty


                all_route_details.append({
                    'mode': 'tram' if route_type == 0 else 'bus',
                    'color': route_color,
                    'name': route_name,
                    'route_id': route_id
                })

    if not all_route_details:
        # Ensure consistent return value count even if no route details are found
        return 'unknown', '#A9A9A9', 'Unknown Route', 'UNK'


    # Prioritize tram if available, otherwise pick a bus route
    for detail in all_route_details:
        if detail['mode'] == 'tram':
            # Return 4 values
            return detail['mode'], detail['color'], detail['name'], detail['route_id']

    # If no tram, return the first bus route found (ensure 4 values are returned)
    first_route = all_route_details[0]
    return first_route['mode'], first_route['color'], first_route['name'], first_route['route_id']


# Second pass: add markers to the mode layers and route layers
for idx, stop in bus_feed.stops.iterrows():
    if pd.notna(stop['stop_lat']) and pd.notna(stop['stop_lon']):
        # Use the get_route_info function to determine mode and route details for popup/tooltip
        transport_mode, route_color, route_name, route_id = get_route_info(stop['stop_id'], bus_feed)

        mode_icon = 'üöå' if transport_mode == 'bus' else ('üöã' if transport_mode == 'tram' else '‚ùì')


        # Create popup with enhanced information
        popup_html = f"""
        <div style="font-family: Arial, sans-serif; width: 220px;">
            <h4 style="margin: 0; color: {route_color}; text-align: center;">
                {mode_icon} {stop.get('stop_name', 'Unknown Stop')}
            </h4>
            <hr style="margin: 8px 0; border: 1px solid {route_color};">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 12px;">
                <b>Stop ID:</b> <span>{stop['stop_id']}</span>
                <b>Mode:</b> <span>{transport_mode.title()}</span>
                <b>Route:</b> <span>{route_name}</span>
                <b>Route ID:</b> <span>{route_id}</span>
            </div>
            <hr style="margin: 8px 0;">
            <div style="font-size: 11px; color: #666;">
                <b>Coordinates:</b><br>
                Lat: {stop['stop_lat']:.6f}<br>
                Lon: {stop['stop_lon']:.6f}
            </div>
        </div>
        """

        # Add markers to Mode Layers (Bus/Tram Stops)
        if transport_mode == 'tram':
            folium.CircleMarker(
                location=[stop['stop_lat'], stop['stop_lon']],
                radius=7,
                popup=folium.Popup(popup_html, max_width=280),
                tooltip=f"üöã {stop.get('stop_name', 'Unknown Stop')} (Route {route_name})",
                color='#2E8B57',  # Dark green border
                fill=True,
                fillColor=route_color,
                fillOpacity=0.85,
                weight=3
            ).add_to(tram_stops_fg) # Add to Tram Stops group
            tram_stop_count += 1
        elif transport_mode == 'bus':
            folium.CircleMarker(
                location=[stop['stop_lat'], stop['stop_lon']],
                radius=5,
                popup=folium.Popup(popup_html, max_width=280),
                tooltip=f"üöå {stop.get('stop_name', 'Unknown Stop')} (Route {route_name})",
                color='#1E90FF',  # Blue border
                fill=True,
                fillColor=route_color,
                fillOpacity=0.75,
                weight=2
            ).add_to(bus_stops_fg) # Add to Bus Stops group
            bus_stop_count += 1
        else: # 'unknown' mode
            unknown_stop_count += 1 # Count unknown stops but don't add to main mode layers

        # Add markers to Individual Route Feature Groups (as clarified by user)
        if transport_mode in ['bus', 'tram']:
             mode_icon = 'üöå' if transport_mode == 'bus' else 'üöã'
             # Use the same naming convention as in cell 5.5 for the FG name
             fg_name = f"{mode_icon} Route {route_name} ({route_id})"
             # Check if the FeatureGroup exists in the dictionary from cell 5.5
             if fg_name in individual_route_fgs:
                 if transport_mode == 'tram':
                     folium.CircleMarker(
                        location=[stop['stop_lat'], stop['stop_lon']],
                        radius=7,
                        popup=folium.Popup(popup_html, max_width=280),
                        tooltip=f"üöã {stop.get('stop_name', 'Unknown Stop')} (Route {route_name})",
                        color='#2E8B57',  # Dark green border
                        fill=True,
                        fillColor=route_color,
                        fillOpacity=0.85,
                        weight=3
                    ).add_to(individual_route_fgs[fg_name]) # Add to the specific individual route FG
                 elif transport_mode == 'bus':
                      folium.CircleMarker(
                        location=[stop['stop_lat'], stop['stop_lon']],
                        radius=5,
                        popup=folium.Popup(popup_html, max_width=280),
                        tooltip=f"üöå {stop.get('stop_name', 'Unknown Stop')} (Route {route_name})",
                        color='#1E90FF',  # Blue border
                        fill=True,
                        fillColor=route_color,
                        fillOpacity=0.75,
                        weight=2
                    ).add_to(individual_route_fgs[fg_name]) # Add to the specific individual route FG


print(f"‚úÖ Stop markers added to feature groups.")
print(f"   üìä Statistics:")
print(f"      ‚Ä¢ Bus stops added: {bus_stop_count}")
print(f"      ‚Ä¢ Tram stops added: {tram_stop_count}")
print(f"      ‚Ä¢ Stops with unknown mode: {unknown_stop_count}")

# Number 9: Add Layers to Map

print("Adding Feature Groups to the map...")

# Add Mode and Stop Layers (created in cell 7) to the map
if 'mode_layers' in globals() and mode_layers:
    for fg in mode_layers.values():
        fg.add_to(zw)
    print(f"‚úÖ Added {len(mode_layers)} mode and stop Feature Groups.")
else:
    print("‚ö†Ô∏è No mode or stop Feature Groups found to add.")


# Add Individual Route Layers (created in cell 5.5) to the map
if 'individual_route_fgs' in globals() and individual_route_fgs:
    for fg in individual_route_fgs.values():
         fg.add_to(zw)
    print(f"‚úÖ Added {len(individual_route_fgs)} individual route Feature Groups.")
else:
     print("‚ö†Ô∏è No individual route Feature Groups found to add.")


# Add Combined Bus Grid Layer (created in cell 5.5) to the map
if 'combined_bus_grid_fg' in globals() and combined_bus_grid_fg is not None:
    combined_bus_grid_fg.add_to(zw)
    print("‚úÖ Added combined bus grid Feature Group.")
else:
    print("‚ö†Ô∏è No combined bus grid Feature Group found to add.")

# Add Individual Tram Line Layer (created in cell 5.5) to the map
if 'individual_tram_line_fg' in globals() and individual_tram_line_fg is not None:
    individual_tram_line_fg.add_to(zw)
    print("‚úÖ Added individual tram line Feature Group.")
else:
    print("‚ö†Ô∏è No individual tram line Feature Group found to add.")


print("‚úÖ All relevant Feature Groups added to the map.")

# Number 10 - Cell 8: Add Layer Controls (Modified Section - Two Separate Controls)

# --- Create Two Separate Layer Controls as requested ---

# 1. Basemap Theme and Individual Routes Control (Standard LayerControl)
# This control will contain base tile layers and individual route feature groups.
# It will automatically pick up base layers. We need to explicitly list the individual route layers.
# Ensure individual_route_fgs is populated from cell 5.5
individual_route_layer_list = list(individual_route_fgs.values()) if 'individual_route_fgs' in globals() and individual_route_fgs else None

# Create the first standard LayerControl for base maps and individual routes
# Note: Standard LayerControl does NOT support adding non-selectable headers like "Tram routes" or "Bus Routes" directly within the list of layers.
# The individual routes will be listed alphabetically or in the order they are added to the list.
folium.LayerControl(
    layers=individual_route_layer_list, # Explicitly specify individual route layers
    position='topright',
    collapsed=True, # Set to True or False as desired
    # Base layers are picked up automatically
).add_to(zw)
print("‚úÖ Basemap Theme and Individual Routes Layer Control added.")


# 2. Transport Modes Control (GroupedLayerControl for Bike, Bus, Tram, Stops, and Gaps)
# This control groups the mode layers defined and populated earlier
# Ensure mode_layers is populated correctly from cell 7, and combined_bus_grid_fg/individual_tram_line_fg from cell 5.5

if 'mode_layers' in globals() and mode_layers:
    # Create the list of layers for the 'üö¶ Transport Modes' group
    # Order as requested: Bike Lanes, Tram, Bus, Walking Gaps, Cycling Gaps, Tram Stops, Bus Stops
    mode_layers_list = [
        mode_layers.get('üö¥ Bike Lanes'),                 # From cell 7
        individual_tram_line_fg if 'individual_tram_line_fg' in globals() else None, # From cell 5.5
        combined_bus_grid_fg if 'combined_bus_grid_fg' in globals() else None,   # From cell 5.5
        mode_layers.get('üö∂ Walking Gaps'),              # From cell 7
        mode_layers.get('üö≤ Cycling Gaps'),              # From cell 7
        mode_layers.get('üöã Tram Stops'),                 # From cell 7
        mode_layers.get('üöå Bus Stops'),                 # From cell 7
    ]

    # Filter out None values if a layer wasn't created (e.g., no bike data or gaps)
    mode_layers_list = [fg for fg in mode_layers_list if fg is not None]

    if mode_layers_list: # Check if there are any mode layers to add
        # Create groups dictionary for modes
        mode_groups_dict = {'üö¶ Transport Modes': mode_layers_list}

        GroupedLayerControl(
            groups=mode_groups_dict,
            exclusive_groups=False, # Allow multiple modes to be selected
            position='topright',    # Adjust position if needed to avoid overlap
            collapsed=True,         # Keep modes collapsed by default
        ).add_to(zw)
        print("‚úÖ Transport Modes Grouped Layer Control added.")
else:
    print("‚ö†Ô∏è Skipping Transport Modes Grouped Layer Control: mode_layers not found or empty.")


print("‚úÖ Layer controls processing complete.")

# --- Add Custom CSS for Scrolling ---
# This CSS needs to target the appropriate container depending on which control needs scrolling.
# If the individual routes LayerControl gets long, we target .leaflet-control-layers-overlays.
# If the modes GroupedLayerControl gets long, we target .leaflet-control-layers-group label + div or similar.
# Given the large number of routes, the first control is more likely to need scrolling.

css = """
<style>
    /* Style for the container that holds the overlay layers in a standard LayerControl */
    /* This targets the first control with individual routes if it's a standard LayerControl */
    .leaflet-control-layers-overlays {
        max-height: 250px; /* Adjust this value as needed to fit the number of routes */
        overflow-y: auto;
        padding-right: 10px; /* Add some padding to avoid scrollbar overlapping content */
        /* Optional: Add a border or background to make the scrollable area visually distinct */
        /* border-top: 1px solid #ddd; */
        /* margin-top: 5px; */
    }

    /* Optional: Style for the scrollbar */
    .leaflet-control-layers-overlays::-webkit-scrollbar {
        width: 8px;
    }

    .leaflet-control-layers-overlays::-webkit-scrollbar-thumb {
        background-color: #ccc; /* Light grey */
        border-radius: 4px;
    }

    .leaflet-control-layers-overlays::-webkit-scrollbar-thumb:hover {
        background-color: #999; /* Darker grey on hover */
    }

    /* If the modes list within the GroupedLayerControl also gets long */
    /*
    .leaflet-control-layers-group label + div {
        max-height: 150px;
        overflow-y: auto;
        padding-right: 10px;
    }
    .leaflet-control-layers-group label + div::-webkit-scrollbar {
        width: 8px;
    }
    .leaflet-control-layers-group label + div::-webkit-scrollbar-thumb {
        background-color: #ccc;
        border-radius: 4px;
    }
    .leaflet-control-layers-group label + div::-webkit-scrollbar-thumb:hover {
        background-color: #999;
    }
    */

</style>
"""

# Add the custom CSS to the map's HTML
# Ensure Element is imported from branca.element
from branca.element import Element
if 'zw' in globals() and zw is not None: # Changed zaragoza_map to zw
    zw.get_root().html.add_child(Element(css))
    print("‚úÖ Custom CSS for scrolling added.")
else:
    print("‚ö†Ô∏è Skipping Custom CSS: zw not found.")


print("‚úÖ Layer controls processing complete.")

# Number 11
# Generate dynamic legend for modes (placed on the left)
def generate_mode_legend(bus_count, tram_count, unknown_count, show_bike_lanes, show_walking_gaps, show_cycling_gaps):
    """Generate HTML legend for modes."""
    legend_html = """
    <div style="position: fixed;
                top: 87px; left: 10px; max-width: 250px; height: auto;
                border: 2px solid #333; z-index: 9999; font-size: 14px;
                background-color: white; opacity: 0.95; border-radius: 10px;
                box-shadow: 0 6px 12px rgba(0,0,0,0.3);">
      <div style="padding: 15px;">
        <h4 style="margin: 0 0 12px 0; color: #333; text-align: center;
                   border-bottom: 2px solid #ddd; padding-bottom: 10px;
                   background: linear-gradient(90deg, #4CAF50, #2196F3);
                   -webkit-background-clip: text; -webkit-text-fill-color: transparent;
                   font-weight: bold;">
          üö¶ Transport Modes
        </h4>
    """

    # Add bike lanes entry
    if show_bike_lanes:
         legend_html += """
         <div style="display: flex; align-items: center; margin-bottom: 8px;">
           <div style="width: 18px; height: 4px; background-color: #F26A0A; margin-right: 10px; flex-shrink: 0;"></div>
           <span style="font-size: 13px; font-weight: 500;">üö¥ Bike Lanes</span>
         </div>
         """

    # Add walking infrastructure gaps entry
    if show_walking_gaps:
         legend_html += """
         <div style="display: flex; align-items: center; margin-bottom: 8px;">
           <div style="width: 18px; height: 4px; background-color: red; margin-right: 10px; flex-shrink: 0;"></div>
           <span style="font-size: 13px; font-weight: 500;">üö∂ Walking Infrastructure Gaps</span>
         </div>
         """
    # Add cycling infrastructure gaps entry
    if show_cycling_gaps:
         legend_html += """
         <div style="display: flex; align-items: center; margin-bottom: 8px;">
           <div style="width: 18px; height: 4px; background-color: purple; margin-right: 10px; flex-shrink: 0;"></div>
           <span style="font-size: 13px; font-weight: 500;">üö≤ Cycling Infrastructure Gaps</span>
         </div>
         """

    # Add bus stops entry
    legend_html += f"""
    <div style="display: flex; align-items: center; margin-bottom: 8px;">
      <div style="width: 14px; height: 14px; border-radius: 50%;
                  background-color: #1E90FF; border: 2px solid #0052CC;
                  margin-right: 10px; flex-shrink: 0; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
      <span style="font-size: 13px; font-weight: 500;">üöå Bus Stops ({bus_count})</span>
    </div>
    """

    # Add tram stops entry
    legend_html += f"""
    <div style="display: flex; align-items: center; margin-bottom: 12px;">
      <div style="width: 16px; height: 16px; border-radius: 50%;
                  background-color: #2E8B57; border: 3px solid #1F6A41;
                  margin-right: 8px; flex-shrink: 0; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
      <span style="font-size: 13px; font-weight: 500;">üöã Tram Stops ({tram_count})</span>
    </div>
    """

    # Add unknown stops count if any
    if unknown_count > 0:
         legend_html += f"""
         <div style="font-size: 11px; color: #666; text-align: center; margin-top: 5px;">
           ‚ùì {unknown_count} stops with unknown/other modes
         </div>
         """


    # Add general instructions
    legend_html += f"""
        <div style="border-top: 2px solid #ddd; padding-top: 10px; margin-top: 12px;">
          <div style="font-size: 11px; color: #666; text-align: center; line-height: 1.4;">
            üí° Click markers for details<br>
            üéõÔ∏è Use layer control for visibility<br>
            üé® Colors from GTFS route data
          </div>
        </div>
      </div>
    </div>
    """
    return legend_html

# Call generate_mode_legend and add to map
# Ensure variables like bus_stop_count, tram_stop_count, unknown_stop_count,
# combined_bike_lanes, gaps_gdf, and cycling_gaps_gdf are available from previous cells.
# Assuming these were correctly populated by running cells 7 and 8.
show_bike_lanes_in_legend = 'combined_bike_lanes' in globals() and combined_bike_lanes is not None and not combined_bike_lanes.empty and combined_bike_lanes.crs is not None
show_walking_gaps_in_legend = 'gaps_gdf' in globals() and gaps_gdf is not None and not gaps_gdf.empty
show_cycling_gaps_in_legend = 'cycling_gaps_gdf' in globals() and cycling_gaps_gdf is not None and not cycling_gaps_gdf.empty

# Ensure stop counts are available from cell 8
if 'bus_stop_count' not in globals():
    bus_stop_count = 0
if 'tram_stop_count' not in globals():
    tram_stop_count = 0
if 'unknown_stop_count' not in globals():
    unknown_stop_count = 0

mode_legend_html = generate_mode_legend(bus_stop_count, tram_stop_count, unknown_stop_count, show_bike_lanes_in_legend, show_walking_gaps_in_legend, show_cycling_gaps_in_legend)
# Ensure the map object is named 'zw' as used in recent cells
if 'zw' in globals() and zw is not None:
    zw.get_root().html.add_child(Element(mode_legend_html))
    print("‚úÖ Mode legend added to the map.")
else:
    print("‚ö†Ô∏è Skipping mode legend: zw map object not found.")


# Generate and add the detailed route legend (placed below the mode legend)
def generate_detailed_route_legend(individual_route_fgs):
    """Generate HTML legend dynamically based on individual route Feature Groups."""
    legend_html = """
    <div style="position: fixed;
                top: 368px; left: 10px; max-width: 400px; height: auto;
                border: 2px solid #333; z-index: 9999; font-size: 14px;
                background-color: white; opacity: 0.95; border-radius: 10px;
                box-shadow: 0 6px 12px rgba(0,0,0,0.3);">
      <div style="padding: 15px;">
        <h4 style="margin: 0 0 12px 0; color: #333; text-align: center;
                   border-bottom: 2px solid #ddd; padding-bottom: 10px;
                   background: linear-gradient(90deg, #FF8C00, #32CD32);
                   -webkit-background-clip: text; -webkit-text-fill-color: transparent;
                   font-weight: bold;">
          üöåüöã Individual Routes
        </h4>
    """

    # Separate bus and tram routes based on FG name prefix
    bus_route_fgs_for_legend = {k: v for k, v in individual_route_fgs.items() if 'üöå' in k}
    tram_route_fgs_for_legend = {k: v for k, v in individual_route_fgs.items() if 'üöã' in k}

    # Add bus routes section as collapsible details
    if bus_route_fgs_for_legend:
        legend_html += f"""
        <details open> <!-- Opened by default for clarity -->
            <summary style="font-weight: bold; cursor: pointer; margin-bottom: 8px;
                           color: #1E90FF; font-size: 15px; padding: 5px;
                           background-color: #f0f8ff; border-radius: 5px;">
                üöå Bus Routes ({len(bus_route_fgs_for_legend)} routes)
            </summary>
            <div style="margin-left: 15px; margin-top: 8px; max-height: 180px;
                       overflow-y: auto; border-left: 3px solid #1E90FF; padding-left: 10px;">
        """
        # Iterate through bus route FGs to get color and name for legend
        # Sorting by FG name (which includes route short name)
        for fg_name, fg in sorted(bus_route_fgs_for_legend.items()):
            route_color = "#0052CC" # Default color
            route_name = fg_name.split(' Route ')[1].split(' (')[0] # Extract route name from FG name

            # --- MODIFIED: Iterate through FG children to find GeoJson and get color ---
            # Iterate through children of the FeatureGroup to find a GeoJson object
            for child_name, child_obj in fg._children.items():
                 # Check if the child is a GeoJson object and has a style_function
                 if isinstance(child_obj, folium.features.GeoJson) and hasattr(child_obj, 'style_function') and child_obj.style_function:
                     try:
                         # Call the style_function to get the style properties
                         # Pass a dummy feature as input
                         dummy_feature = {'properties': {}}
                         style = child_obj.style_function(dummy_feature)
                         if 'color' in style:
                             route_color = style['color']
                             break # Found a color, no need to check other children
                     except Exception as e:
                          # print(f"Warning: Could not get color from style_function for {fg_name} child {child_name}: {e}")
                          pass # Use default color if extraction fails
            # --- END MODIFIED SECTION ---


            legend_html += f"""
            <div style="display: flex; align-items: center; margin-bottom: 6px;
                       padding: 3px; border-radius: 3px; background-color: #fafafa;">
              <div style="width: 14px; height: 14px; border-radius: 50%;
                          background-color: {route_color}; border: 2px solid #1E90FF;
                          margin-right: 10px; flex-shrink: 0; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
              <span style="font-size: 13px; font-weight: 500;">Route {route_name}</span>
            </div>
            """
        legend_html += "</div></details>"

    # Add tram routes section as collapsible details
    if tram_route_fgs_for_legend:
        legend_html += f"""
        <details open style="margin-top: 10px;"> <!-- Opened by default for clarity -->
            <summary style="font-weight: bold; cursor: pointer; margin-bottom: 8px;
                           color: #2E8B57; font-size: 15px; padding: 5px;
                           background-color: #f0fff0; border-radius: 5px;">
                üöã Tram Routes ({len(tram_route_fgs_for_legend)} routes)
            </summary>
            <div style="margin-left: 15px; margin-top: 8px; max-height: 120px;
                       overflow-y: auto; border-left: 3px solid #2E8B57; padding-left: 10px;">
        """
        # Iterate through tram route FGs
        # Sorting by FG name (which includes route short name)
        for fg_name, fg in sorted(tram_route_fgs_for_legend.items()):
            route_color = "#00CC00" # Default green
            route_name = fg_name.split(' Route ')[1].split(' (')[0] # Extract route name from FG name

            # --- MODIFIED: Iterate through FG children to find GeoJson and get color ---
            # Iterate through children of the FeatureGroup to find a GeoJson object
            for child_name, child_obj in fg._children.items():
                 # Check if the child is a GeoJson object and has a style_function
                 if isinstance(child_obj, folium.features.GeoJson) and hasattr(child_obj, 'style_function') and child_obj.style_function:
                     try:
                         # Call the style_function to get the style properties
                         dummy_feature = {'properties': {}}
                         style = child_obj.style_function(dummy_feature)
                         if 'color' in style:
                             route_color = style['color']
                             break # Found a color, no need to check other children
                     except Exception as e:
                          # print(f"Warning: Could not get color from style_function for {fg_name} child {child_name}: {e}")
                          pass # Use default color if extraction fails
            # --- END MODIFIED SECTION ---


            legend_html += f"""
            <div style="display: flex; align-items: center; margin-bottom: 6px;
                       padding: 3px; border-radius: 3px; background-color: #fafafa;">
              <div style="width: 16px; height: 16px; border-radius: 50%;
                          background-color: {route_color}; border: 3px solid #2E8B57;
                          margin-right: 8px; flex-shrink: 0; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
              <span style="font-size: 13px; font-weight: 500;">Route {route_name}</span>
            </div>
            """
        legend_html += "</div></details>"


    # Add general instructions and statistics
    legend_html += f"""
        <div style="border-top: 2px solid #ddd; padding-top: 10px; margin-top: 12px;">
          <div style="font-size: 11px; color: #666; text-align: center; line-height: 1.4;">
            üí° Click markers for details<br>
            üéõÔ∏è Use layer control for visibility<br>
            üé® Colors from GTFS route data
          </div>
        </div>
      </div>
    </div>
    """
    return legend_html

# Call generate_detailed_route_legend and add to map
# Ensure individual_route_fgs is available from cell 5.5
if 'individual_route_fgs' in globals() and individual_route_fgs:
    detailed_route_legend_html = generate_detailed_route_legend(individual_route_fgs)
    if 'zw' in globals() and zw is not None:
        zw.get_root().html.add_child(Element(detailed_route_legend_html))
        print("‚úÖ Detailed route legend added to the map.")
    else:
        print("‚ö†Ô∏è Skipping detailed route legend: zw map object not found.")
else:
    print("‚ö†Ô∏è Skipping detailed route legend: individual_route_fgs not found or empty.")


print("‚úÖ Legends processing complete.")

# Number 12: Display the map
print("Displaying the final map...")
zw

# Number 13: Save the map
map_filename = 'Zaragoza_Mobility_Map.html'
zw.save(map_filename) # Changed gaps_map to zw
print(f"Map saved as '{map_filename}'")